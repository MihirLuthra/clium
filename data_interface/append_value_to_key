#! /usr/bin/env bash

COMMON_PATH="$QUICKTEST_PATH/common"

source "$COMMON_PATH"/constants
source "$COMMON_PATH"/error_handler
source "$DATA_INTERFACE_DIR"/common/common

#
# Description:
#  Creates a temporary file with same contents as
#  param1 but deletes the key param2.
#  At the end key param2 is appended with the new value.
#  Then renames temporary file to param2 hence overwriting
#  previous file.
#  If the key doesn't exist, a new key with this name is added
#  with the given value
#
# param1:
#  file path : created if doesn't exist
#
# param2:
#  Key to set
#
# param3:
#  New value of the key
#
append_value_to_key() {

	local file="$1" ; shift
	local key="$1" ; shift
	local value="$1" ; shift

	[ -z "$file" ] && a_printf_err "param(file) is null" && return 1
	[ -z "$key" ] && a_printf_err "param(key) is null" && return 1
	[ -z "$value" ] && a_printf_err "param(value) is null" && return 1

	exists_but_not_file "$file" && return 1

	touch "$file"

	local temp_file="$(mktemp "/tmp/quicktest.temp.XXXXX")"

	local old_val=$key
	key="$( first_word "$key" )"

	if [ "$old_val" != "$key" ]
	then
		a_printf_err "key cannot contain spaces"
		return 1
	fi

	value="$( trim_leading_and_trailing_blanks "$value" )"

	awk \
		-v key="$key" \
		-v value="$value" \
		-f "$AWK_FILES_PATH/append_value_to_key.awk" \
		"$file" > "$temp_file"

	if [ $? -ne 0 ] ; then
		rm "$temp_file" 2> /dev/null
		a_printf_err "${FUNCNAME[0]}() failed"
		return 1
	fi

	mv "$temp_file" "$file"

}

append_value_to_key "$@"
