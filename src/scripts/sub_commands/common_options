#! /usr/bin/env bash

[ -n "$__SUB_COMMANDS_COMMON__" ] && return 0
readonly __SUB_COMMANDS_COMMON__=1

COMMON_PATH="$QUICKTEST_PATH/"src/scripts/common

set -e
source "$COMMON_PATH"/error_handler
source "$COMMON_PATH"/constants
source "$COMMON_PATH"/utility_funcs
source "$COMMON_PATH"/data_interface
set +e

option_help() {
	less "$( dirname $0 )/help.txt"
}

option_config_file() {
	local prog_name

	prog_name="$(basename "$0")" || return_error
	open_file "$( dirname $0 )/$prog_name.qtc" || return_error
}

get_default_args() {
	local qtc_file
	local default_options
	local prog_name

	prog_name="$(basename "$0")"
	qtc_file="$( dirname "$0" )/$prog_name.qtc"

	default_options="$( get_value_for_key "$qtc_file" "$DEFAULT_ARGS_KEY" )" || {
		a_printf_err \
			"No default args set for $prog_name" \
			"Set key $DEFAULT_ARGS_KEY by $prog_name --config-file"
		return_error
	}

	printf "%s" "$default_options"
}

arg_or_fzf_search() {
	local dir=$1 ; shift
	local message=$1 ; shift
	local option=$1 ; shift
	local file
	local full_path

	if [ ${ARG_CNT[$option]:-0} -eq 1 ]
	then
		file=${ARGS[$option,0]}
	else
		file="$( fzf_search "$message" "$dir" )" || return_error
		[ -z "$file" ] && return_error
	fi

	full_path="$dir/$file"
	print_if_not_file "$full_path" && return_error

	printf "%s" "$full_path"
}

args_or_fzf_multi_search() {
	local dir=$1 ; shift
	local message=$1 ; shift
	local option=$1 ; shift
	local action_template=$1 ; shift
	local replacee=$1 ; shift
	local return_on_fail=$1 ; shift
	local files
	local full_path
	local last_arg
	local arg_no
	local temp_file
	local retval

	declare -a ret_arr

	if [ ${ARG_CNT[$option]:-0} -ge 1 ]
	then
		last_arg="$( expr ${ARG_CNT[$option]} - 1 )"
		for arg_no in $(seq 1 "$last_arg")
		do
			files+=( "${ARGS[$option,$arg_no]}" )
		done
	else
		temp_file="$(mktemp)" || return_error
		# reading null terminated fzf results into an array
		IFS= readarray -t -d '' files < <( fzf_multi_select_search "$message" "$dir" --print0 ; \
			echo $? > "$temp_file")

		retval="$( < "$temp_file" )"
		rm "$temp_file"

		[ "$retval" -ne 0 ] && return_error
	fi

	for file in "${files[@]}"
	do
		full_path="$dir/$file"
		print_if_not_file "$full_path" && return_error

		full_path="$( put_single_quotes "$full_path" )"

		ret_arr+=( "$full_path" )

		if [ -n "$action_template" ]
		then
			action="$( replace "$replacee" "$full_path" "$action_template" )" || return_error
			"${QTBASH}" -c "$action" ; retval=$?
			[ -n "$return_on_fail" ] && [ "$retval" -ne 0 ] && return_error
		fi
	done

	printf "%s " "${ret_arr[@]}"
}

delete_files() {
	local dir=$1 ; shift
	local message=$1
	local action

	action='rm -i __TO_REPLACE__'

	args_or_fzf_multi_search "$dir" "$message" '-d' "$action" '__TO_REPLACE__' '1' > /dev/null
}

open_files() {
	local dir=$1 ; shift
	local message=$1 ; shift
	local option=$1
	local action
	local files_to_open

	action='touch __TO_REPLACE__'

	files_to_open="$( args_or_fzf_multi_search "$dir" "$message" "$option" "$action" '__TO_REPLACE__' '1' )" \
		|| return_error

	set_in_current_defaults "$FILE_TO_OPEN_KEY" "$files_to_open" || return_error

	open="$(get_from_user_config_file_or_default "$HOW_TO_OPEN_EDITOR_KEY")" || return_error

	"$QTBASH" -c "$open" || return_error
}
