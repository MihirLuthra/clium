#! /usr/bin/env bash

# don't source the script twice
[ -n "$__UTILITY_FUNCS__" ] && return 0
readonly __UTILITY_FUNCS__=1

COMMON_PATH="$QUICKTEST_PATH/"src/scripts/common
source "$COMMON_PATH"/error_handler
source "$COMMON_PATH"/constants
source "$DATA_INTERFACE_DIR"/utility_funcs

is_num() {
	case "$1" in
	''|*[!0-9]*) return 1 ;;
	*) return 0 ;;
	esac
}

# trims leading and trailing spaces
# also if more than one blank exists, it trims it to single blank
trim_blanks() {
	awk '{$1=$1}1' <<<"$1"
}

trim_leading_and_trailing_blanks() {

	awk '{
		# trim leading spaces
		sub(/^ +/, "", $0)
		sub(/^\t+/, "", $0)

		# trim trailing spaces
		sub(/ +$/, "", $0)
		sub(/\t+$/, "", $0)
	}1' <<<"$1"
}

first_word() {
	awk '{print $1}' <<<"$1"
}

bold_echo() {
	echo -n "$BOLD"
	echo "$@"
	echo -n "$OFF_BOLD"
}

bold_printf() {
	printf "$BOLD"
	printf "$@"
	printf "$OFF_BOLD"
}

list_time_sorted_null_term() {
	local from_dir=$1 ; shift

	# go to the directory and check glob *, if glob is null, next block will be evaluated
	cd "$from_dir" && 2>&1 compgen -G "*" > /dev/null && {

		# 1) goes through every file in current directory
		# 2) prints inode modification time, a single space and then file name which is null terminated
		# 3) sorts it on the basis of inode modification time
		# 4) gawk then removed time from the output
		find * -type f -exec bash -c 'printf "%s " $(getctime "{}")' \; -print0 \
		| sort -r -n -z -k1 \
		| gawk '
			BEGIN {
				RS="\0"
				ORS="\0"
			}
			{
				r=$1" "
				sub(r, "")
				print
			}
		'
		return_if_error

	} || {
		a_echo_err "Directory is empty"
		return_error
	}
}

list_time_sorted() {
	local from_dir=$1
	local retval

	list_time_sorted_null_term "$from_dir" | tr '\0' '\n'

	[ "${PIPESTATUS[0]:-0}" -ne 0 ] && return_error
	[ "${PIPESTATUS[1]:-0}" -ne 0 ] && return_error

	return 0
}

#
# param1: header
#   This is the heading of fzf search
#
# param2: from_dir
#   The directory where fzf search needs to be done
#
# and rest of args are passed to fzf
#
fzf_search() {
	local header=$1 ; shift
	local from_dir=$1 ; shift

	list_time_sorted_null_term "$from_dir" \
		| fzf -0 --read0 --reverse --height=40% --cycle --header="$header" "$@" || return_error
}

#
# same as fzf_search except it supports
# multiple selection
#
fzf_multi_select_search() {
	local header=$1 ; shift
	local from_dir=$1 ; shift

	list_time_sorted_null_term "$from_dir" \
		| fzf -m -0 --read0 --reverse --height=40% --cycle --header="$header" "$@" || return_error
}

#
# Description:
#  This is used when we maybe overwriting a file.
#  This checks if a path exists and if it is a file,
#  user is asked if file should be overwritten or not.
#
# retval:
#  0  : can write to path
#  1  : don't write to path
#
# param1:
#  path to be checked
#
prompt_if_overwrite() {
	local path=$1

	exists_but_not_file "$path" && return 1
	[ ! -f "$path" ] && return 0
	[ -z "$( < "$path" )" ] && return 0

	printf "%s\n"                            \
			"The file $path already exists." \
			"Should we overwrite it?"

	select user_answer in 'Yes' 'No'
	do
		case "$user_answer" in
			'Yes')
				return 0
				;;
			'No')
				return 1
				;;
		esac
	done

	return 0
}

#
# Description:
#   Sets $FILE_TO_OPEN_KEY in current defaults. This is done
#   so that replace_quicktest_vars is able to replace ___FILE_TO_OPEN___.
#
#   The file is then touched to modify its timestamps and also so
#   that it exists in case it didn't exist before.
#
#   Way to open is fetched fron user config file and stored in a variable.
#   The variable is passed to bash -c to get executed.
#
# param1: file to open
#
open_file() {
	local file=$1 ; shift
	local open

	touch "$file" || return_error

	set_in_current_defaults "$FILE_TO_OPEN_KEY" "$file" || return_error

	open="$(get_from_user_config_file_or_default "$HOW_TO_OPEN_EDITOR_KEY")" || return_error

	"$QTBASH" -c "$open" || return_error
}

replace_first() {
	local replacee=$1 ; shift
	local replacement=$1 ; shift
	local text=$1

	awk -v replacee="$replacee"        \
		-v replacement="$replacement"  \
	'
	BEGIN { exit_status = 1 }

	# MAIN
	{
		if (exit_status && sub(replacee, replacement) == 1) {
			exit_status = 0
		}

		print
	}

	END { exit exit_status }
	' <<<"$text"
}

replace() {
	local replacee=$1 ; shift
	local replacement=$1 ; shift
	local text=$1

	awk -v replacee="$replacee"        \
		-v replacement="$replacement"  \
	'
	BEGIN { exit_status = 1 }

	# MAIN
	{
		if (gsub(replacee, replacement)) {
			exit_status = 0
		}
		print
	}

	END { exit exit_status }
	' <<<"$text"
}

is_bashv4() {
	if [ -n "$BASH_VERSINFO" ]
	then
		if [ $BASH_VERSINFO -lt 4 ]
		then
			return 1
		fi

		return 0
	fi

	return 1
}

fpreprocess() {
	preprocess 2 "$PROGRAM_FUNC_DIR" "$USER_FUNC_DIR" 1 "$ALIAS_FILE_PATH" 1 "$RENAME_FILE_PATH"
}
