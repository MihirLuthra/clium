#! /usr/bin/env bash

#
# TODO:
#  add --get option
#  update current boilerplate on deletion
#
#

COMMON_PATH="$QUICKTEST_PATH/"common

set -e
source "$COMMON_PATH"/error_handler
source "$COMMON_PATH"/constants
source "$COMMON_PATH"/utility_funcs
source "$DATA_INTERFACE_DIR"/utility_funcs

source "$SCRIPTS_DIR"/option_parser
set +e

print_usage() {
	printf_err "%s\n"                                  \
	'quicktest boilerplate'                            \
	'    [-c|--current]'                               \
	'    [-d|--delete <boilerplate_name>]'             \
	'    [-h|--help]'                                  \
	'    [-m|--modify [<boilerplate_name>]]'           \
	'    [-n|--new <boilerplate_name>]'                \
	'    [-p|--path]'                                  \
	'    [-s|--show-all]'
}

parse_boilerplate_options() {
	local option_parser_retval

	parse_options \
		, 'OPTIONS' 'ARG_CNT' 'ARGS' 'self' '0' ';' '--'     \
		                                                     \
		'-c' , '--current'                '0'                \
		'-d' , '--delete'                 '-1'               \
		'-h' , '--help'                   '0'                \
		'-m' , '--modify'                 '-1'               \
		'-n' , '--new'                    '1'                \
		'-p' , '--path'                   '0'                \
		'-s' , '--show-all'               '0'                \
		                                                     \
		';'                                                  \
		"$@"

	option_parser_retval=$?

	if [ $option_parser_retval -ne 0 ] ; then
		option_parser_error_msg $option_parser_retval 'OPTIONS'
		print_usage
		return_error
	fi
}

option_current() {
	local boilerplate

	boilerplate="$(get_from_user_config_file "$BOILERPLATE_KEY")" || return_error

	printf "%s\n" "$boilerplate"
}

option_delete() {
	local boilerplate_full_path
	local boilerplate

	boilerplate=${ARGS[-d,0]}

	if [ ${ARG_CNT[-d]:-0} -eq 1 ]
	then
		boilerplate=${ARGS[-d,0]}
	else
		boilerplate="$( fzf_search "SELECT BOILERPLATE(-d)" "$BOILERPLATE_FILES_DIR" )"
		[ -z "$boilerplate" ] && return_error
	fi

	boilerplate_full_path="$BOILERPLATE_FILES_DIR/$boilerplate"

	print_if_not_file "$boilerplate_full_path" && return_error

	rm -i "$boilerplate_full_path" || return_error
}

option_help() {
	less "$( dirname $BASH_SOURCE )/help.txt"
}

option_modify() {
	local boilerplate_full_path
	local boilerplate

	boilerplate=${ARGS[-m,0]}

	if [ ${ARG_CNT[-m]:-0} -eq 1 ]
	then
		boilerplate=${ARGS[-m,0]}
	else
		boilerplate="$( fzf_search "SELECT BOILERPLATE(-m)" "$BOILERPLATE_FILES_DIR" )"
		[ -z "$boilerplate" ] && return_error
	fi

	boilerplate_full_path="$BOILERPLATE_FILES_DIR/$boilerplate"

	print_if_not_file "$boilerplate_full_path" && return_error

	open_file "$boilerplate_full_path" || return_error
}

option_new() {
	local boilerplate
	local boilerplate_full_path

	boilerplate=${ARGS[-n,0]}
	boilerplate_full_path="$BOILERPLATE_FILES_DIR/$boilerplate"

	exists_but_not_file "$boilerplate_full_path" && return_error

	open_file "$boilerplate_full_path" || return_error
}

option_path() {
	local boilerplate_full_path

	boilerplate_full_path="$BOILERPLATE_FILES_DIR/$(option_current)"

	printf "%s\n" "$boilerplate_full_path"
}

option_show_all() {
	find_by_ctime "$BOILERPLATE_FILES_DIR"
}

boilerplate() {

	parse_boilerplate_options "$@" || return_error

	for option in "${!OPTIONS[@]}"
	do
		case "$option" in
			-c)
				option_current || return_error
				;;
			-d)
				option_delete || return_error
				;;
			-h)
				option_help || return_error
				;;
			-m)
				option_modify || return_error
				;;
			-n)
				option_new || return_error
				;;
			-p)
				option_path || return_error
				;;
			-s)
				option_show_all || return_error
				;;
		esac
	done

	return 0
}

boilerplate "$@"
