#! /usr/bin/env bash


COMMON_PATH="$QUICKTEST_PATH"/common

set -e
source "$COMMON_PATH"/error_handler
source "$COMMON_PATH"/constants
source "$SCRIPTS_DIR"/option_parser
set +e

SUBCMDS_PATH="$SCRIPTS_DIR"/sub_commands


print_quicktest_help() {
	less "$( dirname "$BASH_SOURCE" )/help.txt"
}

print_usage() {

	printf_err "%s\n"               \
	'usage:'                        \
	'quicktest'                     \
	'    [-h|--help]'               \
	'    [<sub_command> [<args>]]'

}

parse_quicktest_options() {

	local option_parser_retval

	parse_options \
		, 'OPTIONS' 'ARG_CNT' 'ARGS' 'self' '0' ';' '--' \
													     \
		'action'      , 'a'                      'S'     \
		'boilerplate' , 'b'                      'S'     \
		'current'     , 'c'                      'S'     \
		'info'        , 'in'                     'S'     \
		'instance'    , 'i'                      'S'     \
		'open'        , 'o'                      'S'     \
		'user_config' , 'u'                      'S'     \
													     \
		'-h'          , '--help'                 '0'     \
													     \
		';'                                              \
		"$@"

	option_parser_retval=$?

	if [ $option_parser_retval -ne 0 ] ; then
		option_parser_error_msg $option_parser_retval 'OPTIONS'
		print_usage
		return_error
	fi

}

main() {

	local shift_count
	local subcmd
	local default_options

	if [ -n "$*" ]
	then
		parse_quicktest_options "$@" || return_error
	else
		parse_quicktest_options "$default_options" || return_error
	fi

	for option in "${!OPTIONS[@]}"
	do
		case "$option" in

			action|boilerplate|current|info|instance|open|user_config)

				# All subcmd here

				# This contains the shift count needed to reach
				# args of subcmds
				shift_count=${OPTIONS[$option]}

				shift $shift_count
				subcmd=$option
				break
				;;
			-h)
				print_quicktest_help
				;;
		esac
	done

	if [ -n "$subcmd" ]
	then
		"${QTBASH}" "$SUBCMDS_PATH/$subcmd/$subcmd" "$@" || return_error
	fi

	return 0
}

main "$@"
