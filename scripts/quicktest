#! /usr/bin/env bash

COMMON_PATH="$QUICKTEST_PATH"/common

set -e
source "$COMMON_PATH"/error_handler
source "$COMMON_PATH"/constants
source "$SCRIPTS_DIR"/option_parser

# GLOBALS
SUBCMDS_PATH="$SCRIPTS_DIR"/sub_commands
CURRENT_DIR="$( dirname "$BASH_SOURCE" )"
QTC_FILE="$CURRENT_DIR"/quicktest.qtc
set +e

print_quicktest_help() {
	less "$( dirname "$BASH_SOURCE" )/help.txt"
}

print_usage() {

	printf_err "%s\n"               \
	'usage:'                        \
	'quicktest'                     \
	'    [-h|--help]'               \
	'    [<sub_command> [<args>]]'

}

parse_quicktest_options() {

	local option_parser_retval

	parse_options \
		, 'OPTIONS' 'ARG_CNT' 'ARGS' 'self' '0' ';' '--' \
		                                                 \
		'action'      , 'a'                      'S'     \
		'boilerplate' , 'b'                      'S'     \
		'func'        , 'f'                      'S'     \
		'instance'    , 'i'                      'S'     \
		'open'        , 'o'                      'S'     \
		'user_config' , 'u'                      'S'     \
		                                                 \
		'-h'          , '--help'                 '0'     \
		                                                 \
		';'                                              \
		"$@"

	option_parser_retval=$?

	if [ $option_parser_retval -ne 0 ] ; then
		option_parser_error_msg $option_parser_retval 'OPTIONS'
		print_usage
		return_error
	fi

}

quicktest() {

	local shift_count
	local subcmd
	local default_options

	if [ -z "$*" ]
	then
		default_options="$( get_value_for_key "$QTC_FILE" "$DEFAULT_ARGS_KEY" )" || return_error
		eval set -- $default_options
	fi

	parse_quicktest_options "$@" || return_error

	for option in "${!OPTIONS[@]}"
	do
		case "$option" in

			action|boilerplate|func|instance|open|user_config)

				# All subcmd here

				# This contains the shift count needed to reach
				# args of subcmds
				shift_count=${OPTIONS[$option]}

				shift $shift_count
				subcmd=$option
				break
				;;
			-h)
				print_quicktest_help
				;;
		esac
	done

	if [ -n "$subcmd" ]
	then
		"$QTBASH" "$SUBCMDS_PATH/$subcmd/$subcmd" "$@" || return_error
	fi

	return 0
}

quicktest "$@"
